#전체 프로젝트 공유 : https://bit.ly/2ZaI9sJ


#0. 학번 : 2103


#[프로젝트 1 : 전자 수에 따른 오비탈의 전자 배치로 확장 및 예외 상황 고려]


##1)연구소 이름  쌈박한 연구소


##2)연구소가 해결하려는 문제  화학에서 원자번호에 따른 전자배치를 공부하는데, 뒷번호로 갈수록 귀찮아지고 지루해진다. 이런 불편함을 겪고있는 학생을 위한 프로젝트지만, 발표영상에서는 학생의 반려견을 페르소나로 삼았다.


##3)연구소의 깃헙 링크  [쌈박한 연구소 깃헙 링크](https://github.com/parkhamint/-project-2019)


##4-1)수정하거나 추가하고 싶은 내용  현재는 원소가 118번까지 있지만 이후 밝혀질 원소들을 대비하여 임의의 전자 수에 대해 가능하도록 수정하고싶다. 부양자수가 spd이후에는 fghij... 알파벳 순으로 전개되므로 함수를 확장하고 오비탈의 에너지 준위의 룰에 맞게 생성하도록 한다면 가능할 것이다.


##4-2)내가 기여한 내용

```
a = int(input('원자 번호를 입력해주세요 : '))
b = int(input('가수를 입력해주세요 : '))
c = a+b #원자, 이온 상태일 때를 고려하도록 원자 번호가 아닌 전자 개수

#오비탈별로 들어갈 수 있는 전자 개수

def f(n) :
    x = n[1]
    if x == 's' :
        return 2
    if x == 'p' :
        return 6
    if x == 'd' :
        return 10
    if x == 'f' :
        return 14
    
# 118번이 채우는 오비탈까지 에너지 준위별로 나열한 것

y = ['1s','2s','2p','3s','3p','4s','3d','4p','5s','4d','5p','6s','4f','5d','6p','7s','5f','6d','7p','8s']
z = []
msg = '' #1s2와 같은 형식으로 문자열을 붙이기 위해서

#각 오비탈별로 대응되는 숫자만큼 전자를 채우고 전자가 남았다면 다음 오비탈에 채우고, 남지 않았다면 끝내도록 작성한 반복문 
for i in y :
    if c>int(f(i)) or c == int(f(i)) :
        c = c-f(i)
        z.append(f(i))
    
    else :
        z.append(c)
        break
#s와 d오비탈이 붙어있는 경우 채워진 전자수가 6개 혹은 11개일 때 s오비탈의 전자가 d오비탈로 이동하는 예외 상황 수정
#예외가 발생하는 전자 수와 그때까지 이용된 오비탈의 종류를 이용하여 예외인 상황을 구별하고, 그때 전자 수를 바꾸는 코드
if len(z) == 7 :
    if z[-1] == 4 or z[-1] == 9 :
        z[-2] = int(z[-2])-1
        z[-1] = int(z[-1])+1

if len(z) == 10 :
    if z[-1] == 4 or z[-1] == 9 :
        z[-2] = int(z[-2])-1
        z[-1] = int(z[-1])+1

if len(z) == 14 :
    if z[-1] == 4 or z[-1] == 9 :
        z[-2] = int(z[-2])-1
        z[-1] = int(z[-1])+1

if len(z) == 18 :
    if z[-1] == 4 or z[-1] == 9 :
        z[-2] = int(z[-2])-1
        z[-1] = int(z[-1])+1

for i in range(len(z)) :
    msg = msg + y[i] + str(z[i]) + ' '
    
print(msg)
```


##5)내가 기여한 내용에 대한 설명 (코드를 개선한 내용을 추가하여 새로 작성하였다)


(1) 기존의 코드가 각 오비탈에 들어갈 수 있는 전자의 개수를 먼저 오비탈을 에너지 준위대로 나열하여 각각의 부양자수에 대응되는 숫자를 일일이 지정했던 것을 오비탈의 –1번째 인덱스가 부양자수이므로 부양자수에 각각 들어갈 수 있는 전자 수가 대응되는 함수를 만들어서 일반화시켰다.  
(2) 중성 원자뿐만 아니라 이온일 경우에도 전자 배치를 보여줄 수 있도록 원자번호와 가수를 입력받는 것으로 확장했다. 둘을 합하여 전자 수만 고려한다면 오비탈의 전자 배치가 가능하다.  
(3) 예외가 발생하는 s2d4 또는 s2d9는 d오비탈의 전자 개수가 4개이거나 9개인 경우이면 s1d5, s1d10이 되도록 하여 예외인 원소를 별개로 처리하지 않을 수 있다. 또한 원자가 아닌 이온도 고려하는 상황이기에 기존처럼 원자번호만 이용하여 예외 상황을 처리할 수 없어 방법을 개선하였다.  
(4) 학술적인 것이나 코드에 관한 설명은 주석 처리하였다.


##6)내가 기여한 내용의 반영 여부 : O


#[프로젝트 2 : 입력받은 물리량에 따른 이동 거리 그래프 도시 개선]


##1)연구소 이름  권순의 연구소


##2)연구소가 해결하려는 문제  가속도를 구하는 데 어려움을 겪고 있는 권순


##3)연구소의 깃헙 링크  [권순의 연구소 깃헙 링크](https://github.com/yttts4354/-/blob/master/정보%20프로젝트)


##4-1)수정하거나 추가하고 싶은 내용  이후 방정식을 푸는 과정까지 함께 print 하고 싶다. 변수별로 방정식을 푸는 방법이 정형화되어 있으므로 가능할 것이다. 또한 저런 상황임을 변수를 통해 구하고 시간을 입력받아서 어떤 시간에서 어떤 물리량을 갖는지 출력하도록 하고 싶다. 물체의 운동이 실제 시뮬레이션이 가능하다면 하고 싶다.


##4-2)내가 기여한 내용


```
#이동 거리, 가속도, 초기 속력, 나중 속력, 시간 중 세 개의 변수를 알면 다른 값을 구할 수 있음
#matplotlib, 글씨체 등..

from matplotlib import pyplot as plt 
from matplotlib import font_manager, rc 
font_name = font_manager.FontProperties(fname="c:/Windows/Fonts/malgun.ttf").get_name() 
rc('font', family=font_name)


x = input('알고있는 변수 3개를 순서에 맞게 입력해주세요. 아닌 변수는 .을 입력해주세요. 띄어쓰기로 나누어주세요. 가능하지 않은 조합은 에러가 납니다 (이동거리 가속도 초기속력 나중속력 시간) : ')

# '.' 으로 입력해 모르는 미지수 2개로 인한 10가지 경우마다 방정식을 푼 것

a = x.split(' ')
b = []

if a[0] == '.' and a[1] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
    a[1] = (a[3] - a[2]) / a[4]
    a[0] = a[2]*a[4] + 0.5*a[1]*a[4]**2
    
    
if a[0] == '.' and a[2] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[2] = a[3]-a[4]*a[1]
    a[0] = a[2]*a[4] + 0.5*a[1]*a[4]**2
    
if a[0] == '.' and a[3] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[3] = a[2] + a[1]*a[4]
    a[0] = a[2]*a[4] + 0.5*a[1]*a[4]**2
    
if a[0] == '.' and a[4] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[4] = (a[3] - a[2]) / a[1]
    a[0] = a[2]*a[4] + 0.5*a[1]*a[4]**2

#루트가 들어가는 경우 플러스와 마이너스가 모두 나오므로 두 종류를 만듦

if a[1] == '.' and a[2] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[1] = ((2*a[4]*a[3]-2*a[1])/a[4])**0.5
    a[2] = a[3]-a[1]*a[4]

    b.append(a[0])
    b.append(a[1]*(-1))
    b.append(a[3]+a[1]*a[4])
    b.append(a[3])
    b.append(a[4])
    
if a[1] == '.' and a[3] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[1] = 2*(a[0]-a[4]*a[2])/a[4]**2
    a[3] = a[2]+a[1]*a[4]
    
if a[1] == '.' and a[4] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[4] = 2*a[0]/(a[2]+a[3])
    a[1] = (a[3]-a[2])/a[4]
    
if a[2] == '.' and a[3] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[3] = (a[1]**2*a[4]+2*a[0])/(a[4]*2)
    a[2] = a[3]-a[4]*a[1]

if a[2] == '.' and a[4] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[2] = (a[3]**2-2*a[1]*a[0])**0.5
    a[4] = (a[3]-a[2])/a[1]

    b.append(a[0])
    b.append(a[1])
    b.append(a[2]*(-1))
    b.append(a[3])
    b.append((a[3]+a[2])/a[1])

if a[3] == '.' and a[4] == '.' :
    for i in range(5) :
        if a[i] != '.' :
            a[i] = float(a[i])
            
    a[3] = (2*a[1]*a[0]+a[2]**2)**0.5
    a[4] = (a[3]-a[2])/a[1]

    b.append(a[0])
    b.append(a[1])
    b.append(a[2])
    b.append(a[3]*(-1))
    b.append((b[3]+a[2])/a[1])
    
print(a)

#이동 거리에 대한 그래프를 b가 있으면 두개, 없으면 한 개만 그래프를 그림.
if len(b) != 0 :
    print(b)

ta = [0]
xa = [0]

tb = [0]
xb = [0]

for i in range(100) :
    t = a[4]*(i+1)/100
    ta.append(t)
    xa.append(a[2]*t+0.5*a[1]*t**2)

plt.plot(ta, xa)
plt.xlabel('시간(초)')
plt.ylabel('거리(m)')
plt.title('등가속도 운동 양상1')
plt.show()
if len(b) != 0 :
    for i in range(100) :
        t = b[4]*(i+1)/100
        tb.append(t)
        xb.append(b[2]*t+0.5*b[1]*t**2)
    plt.plot(tb, xb)
    plt.xlabel('시간(초)')
    plt.ylabel('거리(m)')
    plt.title('등가속도 운동 양상2')
    plt.show()
```


##5)내가 기여한 내용에 대한 설명(코드를 개선한 내용을 추가하여 새로 작성하였다)


(1) 기존에는 4개의 변수 중 3개를 입력받아 식의 해가 없는 경우나 가속도와 최종 속력 중 하나가 0이 아닐 경우 숫자를 바꾸어 부자연스러운 것을 변수 5개에서 3개를 받는 것으로 확장하여 나머지 두 변수를 구하는 방정식을 10종류의 상황에 대해 코드를 새로 작성하였다.  
(2) 등가속도 운동에서 속력은 직선인 것이 자명하고, 오히려 위치에 관한 그래프가 가속도의 부호, 크기 등을 그래프의 개형에 따라 비교할 수 있으므로 이동 거리에 관한 그래프를 추가하였다.  
(3) 부호가 반대인 두 개의 운동이 가능한 경우에는 이를 모두 구하였다.  
(4) 학술적이거나, 코드에 관한 설명은 주석 처리를 하였다.


##6)내가 기여한 내용의 반영 여부 : X


#[프로젝트 3 : 산 염기 적정 시 pH 계산 프로그램 확장]


##1)연구소 이름  지옥연구소


##2)연구소가 해결하려는 문제  화학을 잘 못해 산 염기 적정 시 pH를 구하는데 어려움을 겪고 있는 사람들


##3)연구소의 깃헙 링크  [지옥 연구소 깃헙 링크](https://github.com/dmsdl7322/2503/blob/master)


##4-1)수정하거나 추가하고 싶은 내용  다양성자성 산에 대해서도 적정 곡선을 도시하고 싶다. 또한 지시약 등으로 가시적으로 pH를 나타낼 수 있도록 vpython을 시도하고 싶다. 위의 개념을 응용한다면 적정이 아닌 표준화 상황에서도 pH를 계산하거나 몰수를 계산하는 등 다른 문제도 해결할 수 있을 것이다.


##4-2)내가 기여한 내용


```
import math
import matplotlib.pyplot as plt

# 용액의 액성, 이온화 상수, 부피, 몰농도와 표준 용액의 부피, 몰농도를 입력받음

a = input('적정할 용액의 액성을 입력해주세요 : ')
k = float(input('적정할 용액의 이온화 상수를 입력해주세요 :'))
v1 = float(input('그 용액의 부피(L)는 얼마입니까? : '))
c1 = float(input('그 용액의 몰농도(mol/L)는 얼마입니까? : '))
v2 = float(input('표준용액의 부피(L)는 얼마입니까? : '))
c2 = float(input('표준용액의 몰농도(mol/L)는 얼마입니까? : '))

# 당량점에 도달하기 위한 부피값
# v와 v미만, v초과일 때 계산 방식이 달라서 구분해야 한다
# v에서는 짝염기, 짝산의 가수분해, v미만에서는 헨더슨-하셀바흐, v초과에서는 강산, 강염기가 남은 몰수를 이용해 계산하기 때문

v = c1*v1 / c2

volume = [] # 2v만큼까지 그래프를 그리고자 0부터 2v까지 100등분한 값을 담을 리스트 (그래프 그릴 때 x축)
pH = [] #이후 범위에 따라 계산하고 순서대로 대응되는 pH값을 담을 리스트 (그래프 그릴 때 x축)

#100등분해서 리스트에 순서대로 넣는 것
for i in range(100) :
    volume.append((v*(i+1)/50))

# 49 index는 v인데 반올림되어 로그항에서 음수가 나올 가능성이 있어 따로 빼 계산하고 이후에 넣을 것
volume.remove(volume[49])

# 구하고자 하는 v2의 pH는 리스트 맨 끝에 넣어 같이 계산하고 이후 pop해서 없앨 것
volume.append(v2)

if a == '산' :
    # 표준용액을 넣지 않은 용액의 pH는 volume에 0값이 없어서 따로 계산해야 함
    pH0 = -0.5*math.log10(k*c1)
    
    # volume 내의 용액 부피별로 계산, 값이 v 일 때를 빼서 v 초과와 v 미만 두 케이스
    
    for i in volume :
        # 당량점 이전에는 헨더슨 하셀바흐 식 이용
        if i < v :
            pH.append(-math.log10(k)+math.log10((c2*i)/(c1*v1-c2*i)))
        
        # 당량점 이후에는 강염기가 들어가 몰 수를 이용해 계산할 수 있슴
        else :
            pH.append(14 + math.log10((i*c2-v1*c1)/(i+v1)))
    # 그래프를 그리기 위해서 volume의 첫번째에 부피가 0일 때, pH의 첫번째에 그때의 pH를 insert
    volume.insert(0, 0)    
    pH.insert(0, pH0)
    
    # 계산을 위해 넣고 그래프에는 불필요한 마지막 항을 pop, pH값은 print
    volume.pop()
    print(pH.pop())
    
    # insert가 되어서 49번째가 아니라 50번째에 v와 해당하는 pH를 가수분해를 고려해 계산한 것을 리스트에 넣어준다
    volume.insert(50, v)
    pH.insert(50, (14+0.5*math.log10((c1*v1/(v+v1))*(10**(-14))/k)))

#염기일 때 같은 방식으로 구한 과정
else :
    
    pH0 = 14 + math.log10(((k*c1)**0.5))
    
    for i in volume :
        if i < v :
            pH.append(14+math.log10(k)+math.log10((c1*v1-c2*i)/(c2*i)))
        else :
            pH.append(-math.log10((i*c2-v1*c1)/(i+v1)))
    volume.insert(0, 0)    
    pH.insert(0, pH0)
    
    volume.pop()
    print(pH.pop())
    
    volume.insert(50, v)
    pH.insert(50, (-0.5*math.log10((c1*v1/(i+v1))*(10**(-14))/k)))
    
#그래프 그리기
plt.plot(volume, pH)
plt.show()
```


##5)내가 기여한 내용에 대한 설명(코드를 개선한 내용을 추가하여 새로 작성하였다)


(1) 한정된 산과 염기 종류 이외에 이온화 상수를 아는 상황이라면 계산할 수 있도록 이온화 상수를 입력받는 상황으로 확장하였다.  
(2) 케이스가 나눌 것이 많고, 계산이 복잡하므로 for문을 통해 여러 상황의 값을 계산해 만든 알고리즘을 효율적으로 이용하고자 표준 용액의 부피 이외에도 당량점의 2배 부피까지 적정 곡선이 어떻게 나올지 도시화하였다.  
(3) break문 다음에 else를 이용하여 기존에 의도한 코드가 나오지 않던 오류를 checkpoint를 이용하여 개선하였다.  
(4) 헨더슨 하셀바흐, 가수분해, 강산, 강염기 상황 등 케이스 별 계산 방식 등에 관한 학술적인 내용이나 코드의 목적, 내용에 관한 설명은 주석 처리하였다. 


##6)내가 기여한 내용의 반영 여부 : O
