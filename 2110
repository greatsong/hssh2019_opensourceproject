0.	학번 2110
[프로젝트 1: ]
(1)	연구소 이름: 고기만두연구소
(2)	연구소가 해결하려는 문제: 태양계 구현
(3)	연구소의 깃헙 링크: https://github.com/bborish/BBORISH
(4)	 내가 기여한 내용
      from visual import *
	from visual.graph import *
	

	scene = display (title = 'Planets Orbiting the Sun', width = 800, height = 800, range = vec(25000, 25000, 25000), center = vec(1000, 0, 0))
	scene.autoscale = True #그래프를 설정함
	

	sun = sphere (pos=vec(0,0,0), radius = 100, texture = textures.stucco, color = color.yellow, mass = 10) # 태양의 초기 위치, 반지름, 색깔, 질량 등을 설정함
	

	mercury = sphere (pos = vec(200,0,0), radius = 50, texture = textures.wood, color = color.red) \
	mercury.trail = curve(color = mercury.color)
	mercury.velocity = vector(0,0,295)
	# 수성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정

	venus = sphere (pos = vec(373.664,0,0), radius = 50, texture = textures.wood, color = color.orange)
	venus.trail = curve(color = venus.color)
	venus.velocity = vector(0,0,225)
	# 금성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정

	earth = sphere (pos = vec(516.664,0,0), radius = 50, texture = textures.earth, mass=2)
	earth.trail = curve(color = color.yellow)
	earth.velocity = vector(0,0,195)
	# 지구의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정

	moon = sphere (pos=vec(516.664+5.0016, 0,0), radius = 10, color=color.white)
	moon.trail = curve (color = moon.color)
	moon.velocitylocal = vector(0,0,195+1)
	# 달의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정

	mars = sphere(pos= vec(787.222,0,0), radius = 50, texture= textures.wood, color = color.green)
	mars.trail = curve(color=mars.color)
	mars.velocity = vector(0,0,155)
	# 화성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정
	jupiter = sphere (pos = vec(2688.068,0,0), radius = 75, texture = textures.gravel, color = color.cyan)
	jupiter.trail = curve(color = jupiter.color)
	jupiter.velocity = vector(0,0,70)
	# 목성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정

	saturn = sphere (pos = vec(4920.048,0,0), radius = 75, texture = textures.gravel, color = color.blue)
	saturn.trail = curve(color = saturn.color)
	saturn.velocity = vector(0,0,50)
	# 토성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정
	uranus = sphere (pos = vec(9924.19,0,0), radius = 75, texture = textures.wood, color = color.magenta)
	uranus.trail = curve(color = uranus.color)
	uranus.velocity = vector(0,0,30)
	# 천왕성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정
	neptune = sphere (pos = vec(15544.811,0,0), radius = 75, texture = textures.wood, color = color.red)
	neptune.trail = curve(color =neptune.color)
	neptune.velocity = vector(0,0,23)
	# 해왕성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정
	pluto = sphere (pos = vec(20534.968,0,0), radius = 75, texture = textures.wood, color = color.orange)
	pluto.trail = curve(color = pluto.color)
	pluto.velocity = vector(0,0,.01)
	# 명왕성의 초기 위치, 반지름, 색깔, 질량 등을 설정함
그에 따른 공전 궤도와 공전 속도 설정

	G = -6.7*10**-4
	#중력 상수 설정

	m_sun = 2*10**10
	m_mercury = 3.29*10**3
	m_venus = 4.87*10**4
	m_earth = 6.0*10**4
	m_moon = 7.35*10**2
	m_mars = 6.39*10**3
	m_jupiter = 1.90*10**7
	m_saturn = 5.68*10**6
	m_uranus = 8.68*10**5
	m_neptune = 1.02*10**6
	m_pluto = 1.31*10**2
	m_spaceship =  7.0*10**5
	# 태양계의 행성과 우주선의 실제 질량 고려

	mercury_RealRatio = 1.600
	venus_RealRatio = 1.177
	earth_RealRatio = 1.000
	mars_RealRatio = 0.805
	jupiter_RealRatio = 0.437
	saturn_RealRatio = 0.324
	uranus_RealRatio = 0.228
	neptune_RealRatio = 0.182
	pluto_RealRatio = 0.158
	#태양계의 행성의 실제 공전 속도 고려

	t = 0
	deltat = .01
	time_interval = 0.05
	time_interval_int = int(time_interval/deltat)
	

	graphpos = gdisplay (x=600, y=0, xtitle = "Time", ytitle="Position", width = 600, height=400, title="Position vs.Time of Earth")
	earthposx = gcurve(gdisplay=graphpos, color = color.blue)
	#그래프의 초기 설정

	graphv = gdisplay(x=600, y=500, xtitle = "Time", ytitle="Velocity", width = 600, height = 400, foreground = color.black, background = color.white, title= "Velocity vs. Time of Earth") #시간의 따른 지구의 속도 그래프
	earthvelocity = gcurve(gdisplay = graphv, color = color.blue)
	tlist = []
	vlist = []
	graphGPE = gdisplay (x=800, y=500, xtitle = "Position", ytitle ="Gravitational Potential Energy", width = 600, height = 400, title = "GPE vs. Position of Earth to Sun")
	earthGPE = gcurve(gdisplay = graphGPE, color = color.green)
	#지구에 위치에 따른 태양에 대한 퍼텐셜 에너지 그래프

	graphSpeedRatios = gdisplay (x=600, y=500, xtitle = "Time", ytitle="Speed Ratio", width = 600, height = 400, title = "Planet Speed Ratios to Earth vs. Time")# 지구에 대한 행성들의 상대 속도
	mercuryRatio = gcurve(gdisplay = graphSpeedRatios, color = color.red)
	mercuryRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.red)
	

	venusRatio = gcurve(gdisplay = graphSpeedRatios, color = color.orange)
	venusRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.orange)
	

	earthRatio = gcurve(gdisplay = graphSpeedRatios, color = color.yellow)
	earthRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.yellow)
	

	marsRatio = gcurve(gdisplay = graphSpeedRatios, color = color.green)
	marsRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.green)
	

	jupiterRatio = gcurve(gdisplay = graphSpeedRatios, color = color.cyan)
	jupiterRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.cyan)
	

	saturnRatio = gcurve(gdisplay = graphSpeedRatios, color = color.blue)
	saturnRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.blue)
	

	uranusRatio = gcurve(gdisplay = graphSpeedRatios, color = color.magenta)
	uranusRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.magenta)
	

	neptuneRatio = gcurve(gdisplay = graphSpeedRatios, color = color.red)
	neptuneRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.red)
	

	plutoRatio = gcurve(gdisplay = graphSpeedRatios, color = color.orange)
	plutoRealRatio = gdots(gdisplay = graphSpeedRatios, color = color.orange)
	

	while True :
	    rate(10000)
	    
	    mercury.trail.append(pos=mercury.pos)
	    distanceMercury = mag(mercury.pos)
	    UnitVectorMercury = (mercury.pos - sun.pos)/distanceMercury #행성들의 위치를 설정한 좌표와의 차를 나타내는 벡터로 설정함
	    FgravMercury = (G*m_sun*m_mercury*UnitVectorMercury)/distanceMercury*
    #중력을 GMm/r^2로 나타냄.
	    mercury.velocity = mercury.velocity +(FgravMercury/m_mercury)*deltat
	    mercury.pos = mercury.pos + mercury.velocity*deltat
    #그에 맞게 위치와 속도를 나타냄
	    mercury.rotate(angle = radians(10), axis = vec(0,1,0))
	    if distanceMercury <= sun.radius : break
    #거리가 태양 반지름보다 작아질 수 없음
	    mercury_Ratio = mag(mercury.velocity)/mag(earth.velocity)
	     
	    venus.trail.append(pos=venus.pos)
	    distanceVenus = mag(venus.pos)
	    UnitVectorVenus = (venus.pos - sun.pos)/distanceVenus
	    FgravVenus = (G*m_sun*m_venus*UnitVectorVenus)/distanceVenus**2
	    venus.velocity = venus.velocity + (FgravVenus/m_venus)*deltat
	    venus.pos = venus.pos + venus.velocity*deltat
	    venus.rotate(angle = radians(20), axis = vec(0,1,0))
	    if distanceVenus <= sun.radius : break
	    venus_Ratio = mag(venus.velocity)/mag(earth.velocity)
	    
	    earth.trail.append(pos=earth.pos)
	    distanceEarth = mag(earth.pos)
	    UnitVectorEarth = (earth.pos - sun.pos)/distanceEarth
	    FgravEarth = (G*m_sun*m_earth*UnitVectorEarth)/distanceEarth**2
	    earth.velocity = earth.velocity + (FgravEarth/m_earth)*deltat
	    earth.pos = earth.pos + earth.velocity*deltat
	    earth.rotate(angle = radians(30), axis = vec(0,1,0))
	    earth_GPE = (G*m_sun*m_earth)/distanceEarth
	    if distanceEarth <= sun.radius : break
	    earth_Ratio = mag(earth.velocity)/mag(earth.velocity)
	

	    mars.trail.append(pos=mars.pos)
	    distanceMars = mag(mars.pos)
	    UnitVectorMars = (mars.pos - sun.pos)/distanceMars
	    FgravMars = (G*m_sun*m_mars*UnitVectorMars)/distanceMars**2
	    mars.velocity = mars.velocity +(FgravMars/m_mars)*deltat
	    mars.pos = mars.pos + mars.velocity*deltat
	    mars.rotate(angle = radians(15), axis = vec(0,1,0))
	    if distanceMars <= sun.radius : break
	    mars_Ratio = mag(mars.velocity)/mag(earth.velocity)
	    
	    jupiter.trail.append(pos=jupiter.pos)
	    distanceJupiter = mag(jupiter.pos)
	    UnitVectorJupiter = (jupiter.pos - sun.pos)/distanceJupiter
	    FgravJupiter = (G*m_sun*m_jupiter*UnitVectorJupiter)/distanceJupiter**2
	    jupiter.velocity = jupiter.velocity +(FgravJupiter/m_jupiter)*deltat
	    jupiter.pos = jupiter.pos + jupiter.velocity*deltat
	    jupiter.rotate(angle = radians(15), axis = vec(0,1,0))
	    if distanceJupiter <= sun.radius : break
	    jupiter_Ratio = mag(jupiter.velocity)/mag(earth.velocity)
	    
	    saturn.trail.append(pos=saturn.pos)
	    distanceSaturn = mag(saturn.pos)
	    UnitVectorSaturn = (saturn.pos - sun.pos)/distanceSaturn
	    FgravSaturn = (G*m_sun*m_saturn*UnitVectorSaturn)/distanceSaturn**2
	    saturn.velocity = saturn.velocity +(FgravSaturn/m_saturn)*deltat
	    saturn.pos = saturn.pos + saturn.velocity*deltat
	    saturn.rotate(angle = radians(15), axis = vec(0,1,0))
	    if distanceSaturn <= sun.radius : break
	    saturn_Ratio = mag(saturn.velocity)/mag(earth.velocity)
	    
	    uranus.trail.append(pos=uranus.pos)
	    distanceUranus = mag(uranus.pos)
	    UnitVectorUranus = (uranus.pos - sun.pos)/distanceUranus
	    FgravUranus = (G*m_sun*m_uranus*UnitVectorUranus)/distanceUranus**2
	    uranus.velocity = uranus.velocity +(FgravUranus/m_uranus)*deltat
	    uranus.pos = uranus.pos + uranus.velocity*deltat
	    uranus.rotate(angle = radians(15), axis = vec(0,1,0))
	    if distanceUranus <= sun.radius : break
	    uranus_Ratio = mag(uranus.velocity)/mag(earth.velocity)
	    
	    neptune.trail.append(pos=neptune.pos)
	    distanceNeptune = mag(neptune.pos)
	    UnitVectorNeptune = (neptune.pos - sun.pos)/distanceNeptune
	    FgravNeptune = (G*m_sun*m_neptune*UnitVectorNeptune)/distanceNeptune**2
	    neptune.velocity = neptune.velocity +(FgravNeptune/m_neptune)*deltat
	    neptune.pos = neptune.pos + neptune.velocity*deltat
	    neptune.rotate(angle = radians(15), axis = vec(0,1,0))
	    if distanceNeptune <= sun.radius : break
	    neptune_Ratio = mag(neptune.velocity)/mag(earth.velocity) 
	    
	    pluto.trail.append(pos=pluto.pos)
	    distancePluto = mag(pluto.pos)
	    UnitVectorPluto  = (pluto.pos - sun.pos)/distancePluto 
	    FgravPluto  = (G*m_sun*m_pluto*UnitVectorPluto )/distancePluto **2
	    pluto.velocity = pluto.velocity +(FgravPluto /m_pluto)*deltat
	    pluto.pos = pluto.pos + pluto.velocity*deltat
	    pluto.rotate(angle = radians(15), axis = vec(0,1,0))
	    if distancePluto  <= sun.radius : break
	    pluto_Ratio = mag(pluto.velocity)/mag(earth.velocity) 
	    
	    earthposx.plot(pos=(t,earth.pos.x))
	    earthvelocity.plot(pos=(t,earth.velocity.x))
	    earthGPE.plot(pos=(earth.pos.x,earth_GPE))
	    
	    
	    vlist.append(earth.velocity.x)
	    tlist.append(t)
	    t = t + deltat
	

	    mercuryRatio.plot(pos=(t,mercury_Ratio))
	    mercuryRealRatio.plot(pos=(t,mercury_RealRatio))
	    
	    venusRatio.plot(pos=(t,venus_Ratio))
	    venusRealRatio.plot(pos=(t,venus_RealRatio))
	    
	    earthRatio.plot(pos=(t,earth_Ratio))
	    earthRealRatio.plot(pos=(t,earth_RealRatio))
	    
	    marsRatio.plot(pos=(t,mars_Ratio))
	    marsRealRatio.plot(pos=(t,mars_RealRatio))
	    
	    jupiterRatio.plot(pos=(t,jupiter_Ratio))
	    jupiterRealRatio.plot(pos=(t,jupiter_RealRatio))
	    
	    saturnRatio.plot(pos=(t,saturn_Ratio))
	    saturnRealRatio.plot(pos=(t,saturn_RealRatio))
	    
	    uranusRatio.plot(pos=(t,uranus_Ratio))
	    uranusRealRatio.plot(pos=(t,uranus_RealRatio))
	    
	    neptuneRatio.plot(pos=(t,neptune_Ratio))
	    neptuneRealRatio.plot(pos=(t,neptune_RealRatio))
	    
	    plutoRatio.plot(pos=(t,pluto_Ratio))
	    plutoRealRatio.plot(pos=(t,pluto_RealRatio))
	    #행성별 공전 경로와 실제 경로를 시간에 따라 나타냄
	    t = t + deltat
    #시간이 지남에 따라 시간을 변화 시켜줌

(5)	내가 기여한 내용에 대한 설명: 주석을 첨부하였다.
(6)	내가 기여한 내용의 반영 여부: X

[프로젝트 2: ]
(1)연구소 이름: 연구소 이름을 까먹은 연구팀의 연구소(진짜 까먹었어요 죄송합니다)
(2)연구소가 해결하려는 문제: 탄소 순환을 이용한 지구온난화 분석 및 '인류 멸망 주식회사'
(3)연구소의 깃헙 링크: https://github.com/Usernam02/2508-2510
(4)내가 기여한 내용
class Queue :
    def __init__(self) :
        self.items = []
    def enqueue(self,item) :
        self.items.insert(0,item) 
    def dequeue(self) :
        return self.items.pop()
    def isEmpty(self) :
        return self.items == []
    def size(self) :
        return len(self.items)
g = Queue()
k = Queue()
b = Queue()
s = Queue()
for i in range(0,100):
    g.enqueue(1)
    k.enqueue(1)
    b.enqueue(1)
    s.enqueue(1)
a1 = g.size() // 3
a2 = k.size() // 4
a3 = b.size() // 2
a4 = s.size() // 5
for i in range(a1) :
    g.dequeue()
for i in range(a2) :
    k.dequeue()
for i in range(a3) :
    b.dequeue()
for i in range(a4) :
    s.dequeue()
for i in range(a2) :
    g.enqueue(1)
for i in range(a3) :
    k.enqueue(1)
for i in range(a4) :
    b.enqueue(1)
for i in range(a1) :
    s.enqueue(1)
print(g.size())
print(k.size())
print(b.size())
print(s.size())
q=True                                       #f= 수확량
wf=input('뭐 먹을래? 감자 보리 밀 옥수수 쌀 인공 음식 빵     ')
if wf=='감자' :
    f=292
elif wf=='보리' :
    f=176
elif wf=='밀' :
    f=248
elif wf=='쌀' :
    f=264
elif wf=='채소' :
    f=2
elif wf=='빵' :
    print('빵이 없으면 캐이크를 먹어-말이 안통하네트')
    q=False
elif wf=='인공 음식' :
    f=10000000
elif wf=='옥수수' :
    f=496
elif wf=='안 먹을래':
    f=0
else :
    print('그런 거 없다 반동분자야')
    q=False
a=10000
g=10000
h=70
at=[]
gt=[]
wt=[]
ht=[]
w=1000
y=2019
while q :
    b=int(input('편안함'))
    for i in range(1,41):
        at.append(a)
        gt.append(g)
        wt.append(w)
        ht.append(h)
        y=y+1                         #해는 1년씩 늘어남
        nw=int(a*0.1)
        bh=int(b*h)
        bh1=int(bh*0.4)
        bh2=int(bh*0.1)
        f1=int(f*0.1)
        a=a+w-nw+h+bh2-f1            #1년 후 이산화탄소의 양
        g=g-bh+f-h                   #1년 후 화석 연료의 양
        w=nw
        dh=int(0.08*h)
        nh=int(0.02*bh)
         
        if a<3000 :                     #이산화탄소 농도가 너무 낮으면 호흡이 안되서 농사가 망함
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('농사가 망했습니다 you die')
            at.append(a)
            q=False
            break
        
        elif f-h<0 :                #인구에 비해 수확량이 적으면 정부에 반기를 든 분노한 시민들이 폭동을 일으킵니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('수확량이 부족합니다 폭동이 일어났습니다 you die')
            q=False
            break
        elif b>5000:
            print('과연 괜찮을 까요 식량은요? 화석연료는요? 이산화 탄소는요?')
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='') 
            q=False
            break
        elif  f-h-300>0 :                #인구에 비해 수확량이 압도적으로 많으면 농지를 처분해야 합니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('수확량이 많습니다. 슬슬 농업용 토지를 처분해야 합니다.')
            q=False
            break
        elif g<0 :                  #화석 연료가 없어서 너는 굶어 죽습니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print('화석 연료가 다 떨어졌습니다 가장 현실에 가깝습니다 you die')
            gt.append(g)
            q=False
            break
        elif a>30000:               #이산화탄소 농도가 너무 높으면 질식사합니다
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print('숨이 막혀 오는 것이 느껴집니다 you die')
            at.append(a)
            q=False
            break
        elif f-h>500 :             #수확량이 인구에 비해 너무 많으면 넘쳐나는 음식물 쓰레기를 주체할 수 없게 됩니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print('음식물 쓰레기가 너무 많습니다 you die')
            q=False
            break
        elif h>12000000000 :   #인구가 너무 많으면 주거공간이 모자라게 됩니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('주거공간이 모자랍니다 폭동이 일어났습니다. you die')
            q=False
        elif h<1 :   # 지구에 살아있는 인류가 없습니다.
            print('서기', end='')
            print(y, end='')
            print('년', end=' ')
            print(wf, end='')
            print('지구위에 살아있는 인류는 없습니다. you die')
            q=False
        else :
            h=h-dh+nh
    import matplotlib.pyplot as plt
    plt.figure(figsize = (5,3), dpi = 300) # 그래프 크기 및 해상도 조절
    plt.rc('font',family='Malgun Gothic') # 한글 폰트설정
    plt.plot(at, '.')
    plt.title('a') # 제목 넣기
    plt.xlim(0,len(at)+1) # x축 값 범위
    plt.ylim(1000,21000) # y축 값 범위
    plt.xlabel('x축') # x축 레이블
    plt.ylabel('y축') # y축 레이블
    plt.savefig('data.png') # 파일 저장
    plt.show() # 그래프 보여주기
    print(at)
    print(gt)
    print(wt)
    print(ht)
 (5)내가 기여한 내용에 대한 설명 : 코드를 일부 수정함 지구가 멸망하는 경우의 수를 추가하였고 빵을 목록에 추가하고 안 먹을래를 추가하여 수확량이 0인 경우를 제시함
(6)내가 기여한 내용의 반영 여부:X

[프로젝트 3: ]
(1)연구소 이름: 거인 연구소
(2)연구소가 해결하려는 문제: 임의의 염기서열이 주어졌을 때 폴리펩타이드 아미노산 구하기
(3)연구소의 깃헙 링크: https://github.com/aminoacidteam/ang
(4)내가 기여한 내용
def comp(seq):  #상보적 방식 함수
	    comp_dict={'A':'T', 'T':'A', 'C':'G', 'G':'C'}
    # 염기의 상보적 결합 설정
	    seq_comp=""
	    for char in seq:
	        if char in comp_dict:
	            seq_comp = seq_comp + comp_dict[char]
	        else:
	            seq_comp = seq_comp + '?'
	    return seq_comp # 5’, 3’ 설정이 없는 배열
	 
	def rev(seq): #역순 방식 함수
	    comp_dict={'A':'A', 'T':'T', 'C':'C', 'G':'G'}
# 염기 서열 설정
	    rev_str = "".join(reversed(seq))
	    seq_rev = ""
	    for char in rev_str:
	        if char in comp_dict:
	            seq_rev = seq_rev + comp_dict[char]
	        else:
	            seq_rev = seq_rev + '?'
	    return seq_rev # 염기 서열을 뒤집어 5’, 3’ 반영
	 
	def rev_comp(seq): #상보적 역순 방식 함수
	    return (rev(comp(seq)))
	 
	

	src = input("DNA seq: ") DNA 염기 서열 받기
	cnvt = int(input("1(Comp) 2(Rev) 3(Rev_Comp)"))
	

	if cnvt == 1:
	    rslt = comp(src)
	elif cnvt == 2:
	    rslt = rev(src)
	else:
	    rslt = rev_comp(src)
	    
	print(rslt) # 이 두 함수의 기능을 합쳐 전사를 하는 코드
          
(def translate(): 
	    table = { 
	'ATA':'ILEU-', 'ATC':'ILEU-', 'ATT':'ILEU-', 'ATG':'MET-', 
	        'ACA':'THR-', 'ACC':'THR-', 'ACG':'THR-', 'ACT':'THR-', 
	        'AAC':'ASN-', 'AAT':'ASN-', 'AAA':'LYS-', 'AAG':'LYS-', 
	        'AGC':'SER-', 'AGT':'SER-', 'AGA':'ARG-', 'AGG':'ARG-',                  
	        'CTA':'LEU-', 'CTC':'LEU-', 'CTG':'LEU-', 'CTT':'LEU-', 
	        'CCA':'PRO-', 'CCC':'PRO-', 'CCG':'PRO-', 'CCT':'PRO-', 
	        'CAC':'HIS-', 'CAT':'HIS-', 'CAA':'GLN-', 'CAG':'GLN-', 
	        'CGA':'ARG-', 'CGC':'ARG-', 'CGG':'ARG-', 'CGT':'ARG-', 
	        'GTA':'VAL-', 'GTC':'VAL-', 'GTG':'VAL-', 'GTT':'VAL-', 
	        'GCA':'ALA-', 'GCC':'ALA-', 'GCG':'ALA-', 'GCT':'ALA-', 
	        'GAC':'ASP-', 'GAT':'ASP-', 'GAA':'GLU-', 'GAG':'GLU-', 
	        'GGA':'GLY-', 'GGC':'GLY-', 'GGG':'GLY-', 'GGT':'GLY-', 
	        'TCA':'SER-', 'TCC':'SER-', 'TCG':'SER-', 'TCT':'SER-', 
	        'TTC':'PHE-', 'TTT':'PHE-', 'TTA':'LEU-', 'TTG':'LEU-', 
	        'TAC':'TYR-', 'TAT':'TYR-', 'TAA':'_', 'TAG':'_', 
	        'TGC':'CYS-', 'TGT':'CYS-', 'TGA':'_', 'TGG':'TRY-', 
	

	    } # 코돈 별 염기서열을 저장함
	    protein ="" 
	    sm = False
	    if len(rslt)%3 == 0: 
	        for i in range(0, len(rslt), 3):
	

	            codon = rslt[i:i + 3]
	               #코돈을 3개씩 쪼개는 코드

	            if codon == 'ATG':
	                sm = True
	

	            if sm == True:
	                if codon == ('TAA' or 'TAG' or 'TGA'):
	                    return protein # 스탑 코돈을 서정함
	                else: 
	                    protein+= table[codon] 
	                 
	    return False # 3개씩 나눠떨어지지 않는다면 폴리펩타이드를 출력하지 않는다.
	             




(5)내가 기여한 내용에 대한 설명 주석을 추가함
(6)내가 기여한 내용의 반영 여부: X



